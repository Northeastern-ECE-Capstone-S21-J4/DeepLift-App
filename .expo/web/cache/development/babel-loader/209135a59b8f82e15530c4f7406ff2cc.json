{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from \"./utils/serialize\";\nimport { DOCUMENT_ID } from \"./FirestoreFieldPath\";\nvar OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  in: 'IN'\n};\nvar INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true\n};\nvar DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n\nvar FirestoreQueryModifiers = function () {\n  function FirestoreQueryModifiers() {\n    _classCallCheck(this, FirestoreQueryModifiers);\n\n    this._limit = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _createClass(FirestoreQueryModifiers, [{\n    key: \"_copy\",\n    value: function _copy() {\n      var newInstance = new FirestoreQueryModifiers();\n      newInstance._limit = this._limit;\n      newInstance._filters = _toConsumableArray(this._filters);\n      newInstance._orders = _toConsumableArray(this._orders);\n      newInstance._type = this._type;\n      newInstance._startAt = this._startAt;\n      newInstance._startAfter = this._startAfter;\n      newInstance._endAt = this._endAt;\n      newInstance._endBefore = this._endBefore;\n      return newInstance;\n    }\n  }, {\n    key: \"filters\",\n    get: function get() {\n      return this._filters.map(function (f) {\n        return _objectSpread(_objectSpread({}, f), {}, {\n          fieldPath: f.fieldPath._toArray()\n        });\n      });\n    }\n  }, {\n    key: \"orders\",\n    get: function get() {\n      return this._orders;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      var options = {};\n\n      if (this._limit) {\n        options.limit = this._limit;\n      }\n\n      if (this._startAt) {\n        options.startAt = this._startAt;\n      }\n\n      if (this._startAfter) {\n        options.startAfter = this._startAfter;\n      }\n\n      if (this._endAt) {\n        options.endAt = this._endAt;\n      }\n\n      if (this._endBefore) {\n        options.endBefore = this._endBefore;\n      }\n\n      return options;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"setFieldsCursor\",\n    value: function setFieldsCursor(cursor, fields) {\n      this[\"_\" + cursor] = buildNativeArray(fields);\n      return this;\n    }\n  }, {\n    key: \"hasStart\",\n    value: function hasStart() {\n      return !!(this._startAt || this._startAfter);\n    }\n  }, {\n    key: \"hasEnd\",\n    value: function hasEnd() {\n      return !!(this._endAt || this._endBefore);\n    }\n  }, {\n    key: \"asCollectionGroupQuery\",\n    value: function asCollectionGroupQuery() {\n      this._type = 'collectionGroup';\n      return this;\n    }\n  }, {\n    key: \"isCollectionGroupQuery\",\n    value: function isCollectionGroupQuery() {\n      return this._type === 'collectionGroup';\n    }\n  }, {\n    key: \"isValidLimit\",\n    value: function isValidLimit(limit) {\n      return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(_limit) {\n      this._limit = _limit;\n      return this;\n    }\n  }, {\n    key: \"isValidOperator\",\n    value: function isValidOperator(operator) {\n      return !!OPERATORS[operator];\n    }\n  }, {\n    key: \"isEqualOperator\",\n    value: function isEqualOperator(operator) {\n      return OPERATORS[operator] === 'EQUAL';\n    }\n  }, {\n    key: \"isInOperator\",\n    value: function isInOperator(operator) {\n      return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY';\n    }\n  }, {\n    key: \"where\",\n    value: function where(fieldPath, opStr, value) {\n      var filter = {\n        fieldPath: fieldPath,\n        operator: OPERATORS[opStr],\n        value: generateNativeData(value)\n      };\n      this._filters = this._filters.concat(filter);\n      return this;\n    }\n  }, {\n    key: \"validateWhere\",\n    value: function validateWhere() {\n      var hasInequality;\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        if (!INEQUALITY[filter.operator]) {\n          continue;\n        }\n\n        if (!hasInequality) {\n          hasInequality = filter;\n          continue;\n        }\n\n        if (INEQUALITY[filter.operator] && hasInequality) {\n          if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n            throw new Error(\"Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '\" + hasInequality.fieldPath._toPath() + \"' and '\" + filter.fieldPath._toPath() + \"'\");\n          }\n        }\n      }\n\n      var hasArrayContains;\n      var hasArrayContainsAny;\n      var hasIn;\n\n      for (var _i = 0; _i < this._filters.length; _i++) {\n        var _filter = this._filters[_i];\n\n        if (_filter.operator === OPERATORS['array-contains']) {\n          if (hasArrayContains) {\n            throw new Error('Invalid query. Queries only support a single array-contains filter.');\n          }\n\n          hasArrayContains = true;\n        }\n\n        if (_filter.operator === OPERATORS['array-contains-any']) {\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use more than one 'array-contains-any' filter.\");\n          }\n\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\");\n          }\n\n          hasArrayContainsAny = true;\n        }\n\n        if (_filter.operator === OPERATORS.in) {\n          if (hasIn) {\n            throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n          }\n\n          if (hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\");\n          }\n\n          hasIn = true;\n        }\n      }\n    }\n  }, {\n    key: \"isValidDirection\",\n    value: function isValidDirection(directionStr) {\n      return !!DIRECTIONS[directionStr.toLowerCase()];\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(fieldPath, directionStr) {\n      var order = {\n        fieldPath: fieldPath._toPath(),\n        direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc\n      };\n      this._orders = this._orders.concat(order);\n      return this;\n    }\n  }, {\n    key: \"validateOrderBy\",\n    value: function validateOrderBy() {\n      if (this._orders.length > 1) {\n        var orders = this._orders.map(function ($) {\n          return $.fieldPath;\n        });\n\n        var set = new Set(orders);\n\n        if (set.size !== orders.length) {\n          throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n        }\n      }\n\n      if (this._filters.length === 0) {\n        return;\n      }\n\n      for (var i = 0; i < this._filters.length; i++) {\n        var filter = this._filters[i];\n\n        var filterFieldPath = filter.fieldPath._toPath();\n\n        for (var k = 0; k < this._orders.length; k++) {\n          var order = this._orders[k];\n          var orderFieldPath = order.fieldPath;\n\n          if (filter.operator === OPERATORS['==']) {\n            if (filterFieldPath === orderFieldPath) {\n              throw new Error(\"Invalid query. Query.orderBy() parameter: \" + orderFieldPath + \" cannot be the same as your Query.where() fieldPath parameter: \" + filterFieldPath);\n            }\n          }\n\n          if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n            throw new Error(\"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\");\n          }\n\n          if (INEQUALITY[filter.operator]) {\n            if (filterFieldPath !== this._orders[0].fieldPath) {\n              throw new Error(\"Invalid query. Initial Query.orderBy() parameter: \" + orderFieldPath + \" has to be the same as the Query.where() fieldPath parameter(s): \" + filterFieldPath + \" when an inequality operator is invoked \");\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return FirestoreQueryModifiers;\n}();\n\nexport { FirestoreQueryModifiers as default };","map":{"version":3,"sources":["/Users/630556369qqcom/Desktop/DeepLift-App/node_modules/@react-native-firebase/firestore/lib/FirestoreQueryModifiers.js"],"names":["isNumber","buildNativeArray","generateNativeData","DOCUMENT_ID","OPERATORS","in","INEQUALITY","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","DIRECTIONS","asc","desc","FirestoreQueryModifiers","_limit","undefined","_filters","_orders","_type","_startAt","_startAfter","_endAt","_endBefore","newInstance","map","f","fieldPath","_toArray","options","limit","startAt","startAfter","endAt","endBefore","cursor","fields","Math","floor","operator","opStr","value","filter","concat","hasInequality","i","length","_toPath","Error","hasArrayContains","hasArrayContainsAny","hasIn","directionStr","toLowerCase","order","direction","orders","$","set","Set","size","filterFieldPath","k","orderFieldPath"],"mappings":";;;;;;;;;AAiBA,SAASA,QAAT,QAAyB,uCAAzB;AACA,SAASC,gBAAT,EAA2BC,kBAA3B;AACA,SAASC,WAAT;AAEA,IAAMC,SAAS,GAAG;AAChB,QAAM,OADU;AAEhB,OAAK,cAFW;AAGhB,QAAM,uBAHU;AAIhB,OAAK,WAJW;AAKhB,QAAM,oBALU;AAMhB,oBAAkB,gBANF;AAOhB,wBAAsB,oBAPN;AAQhBC,EAAAA,EAAE,EAAE;AARY,CAAlB;AAWA,IAAMC,UAAU,GAAG;AACjBC,EAAAA,SAAS,EAAE,IADM;AAEjBC,EAAAA,kBAAkB,EAAE,IAFH;AAGjBC,EAAAA,YAAY,EAAE,IAHG;AAIjBC,EAAAA,qBAAqB,EAAE;AAJN,CAAnB;AAOA,IAAMC,UAAU,GAAG;AACjBC,EAAAA,GAAG,EAAE,WADY;AAEjBC,EAAAA,IAAI,EAAE;AAFW,CAAnB;;IAKqBC,uB;AACnB,qCAAc;AAAA;;AACZ,SAAKC,MAAL,GAAcC,SAAd;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,KAAL,GAAa,YAAb;AAEA,SAAKC,QAAL,GAAgBJ,SAAhB;AACA,SAAKK,WAAL,GAAmBL,SAAnB;AACA,SAAKM,MAAL,GAAcN,SAAd;AACA,SAAKO,UAAL,GAAkBP,SAAlB;AACD;;;;WAED,iBAAQ;AACN,UAAMQ,WAAW,GAAG,IAAIV,uBAAJ,EAApB;AACAU,MAAAA,WAAW,CAACT,MAAZ,GAAqB,KAAKA,MAA1B;AACAS,MAAAA,WAAW,CAACP,QAAZ,sBAA2B,KAAKA,QAAhC;AACAO,MAAAA,WAAW,CAACN,OAAZ,sBAA0B,KAAKA,OAA/B;AACAM,MAAAA,WAAW,CAACL,KAAZ,GAAoB,KAAKA,KAAzB;AACAK,MAAAA,WAAW,CAACJ,QAAZ,GAAuB,KAAKA,QAA5B;AACAI,MAAAA,WAAW,CAACH,WAAZ,GAA0B,KAAKA,WAA/B;AACAG,MAAAA,WAAW,CAACF,MAAZ,GAAqB,KAAKA,MAA1B;AACAE,MAAAA,WAAW,CAACD,UAAZ,GAAyB,KAAKA,UAA9B;AACA,aAAOC,WAAP;AACD;;;SAED,eAAc;AACZ,aAAO,KAAKP,QAAL,CAAcQ,GAAd,CAAkB,UAAAC,CAAC;AAAA,+CAAUA,CAAV;AAAaC,UAAAA,SAAS,EAAED,CAAC,CAACC,SAAF,CAAYC,QAAZ;AAAxB;AAAA,OAAnB,CAAP;AACD;;;SAED,eAAa;AACX,aAAO,KAAKV,OAAZ;AACD;;;SAED,eAAc;AACZ,UAAMW,OAAO,GAAG,EAAhB;;AAEA,UAAI,KAAKd,MAAT,EAAiB;AACfc,QAAAA,OAAO,CAACC,KAAR,GAAgB,KAAKf,MAArB;AACD;;AACD,UAAI,KAAKK,QAAT,EAAmB;AACjBS,QAAAA,OAAO,CAACE,OAAR,GAAkB,KAAKX,QAAvB;AACD;;AACD,UAAI,KAAKC,WAAT,EAAsB;AACpBQ,QAAAA,OAAO,CAACG,UAAR,GAAqB,KAAKX,WAA1B;AACD;;AACD,UAAI,KAAKC,MAAT,EAAiB;AACfO,QAAAA,OAAO,CAACI,KAAR,GAAgB,KAAKX,MAArB;AACD;;AACD,UAAI,KAAKC,UAAT,EAAqB;AACnBM,QAAAA,OAAO,CAACK,SAAR,GAAoB,KAAKX,UAAzB;AACD;;AAED,aAAOM,OAAP;AACD;;;SAED,eAAW;AACT,aAAO,KAAKV,KAAZ;AACD;;;WAED,yBAAgBgB,MAAhB,EAAwBC,MAAxB,EAAgC;AAC9B,iBAASD,MAAT,IAAqBlC,gBAAgB,CAACmC,MAAD,CAArC;AACA,aAAO,IAAP;AACD;;;WAMD,oBAAW;AACT,aAAO,CAAC,EAAE,KAAKhB,QAAL,IAAiB,KAAKC,WAAxB,CAAR;AACD;;;WAED,kBAAS;AACP,aAAO,CAAC,EAAE,KAAKC,MAAL,IAAe,KAAKC,UAAtB,CAAR;AACD;;;WAMD,kCAAyB;AACvB,WAAKJ,KAAL,GAAa,iBAAb;AACA,aAAO,IAAP;AACD;;;WAED,kCAAyB;AACvB,aAAO,KAAKA,KAAL,KAAe,iBAAtB;AACD;;;WAMD,sBAAaW,KAAb,EAAoB;AAClB,aAAO,CAAC9B,QAAQ,CAAC8B,KAAD,CAAT,IAAoBO,IAAI,CAACC,KAAL,CAAWR,KAAX,MAAsBA,KAA1C,IAAmDA,KAAK,IAAI,CAAnE;AACD;;;WAED,eAAMA,MAAN,EAAa;AACX,WAAKf,MAAL,GAAce,MAAd;AACA,aAAO,IAAP;AACD;;;WAMD,yBAAgBS,QAAhB,EAA0B;AACxB,aAAO,CAAC,CAACnC,SAAS,CAACmC,QAAD,CAAlB;AACD;;;WAED,yBAAgBA,QAAhB,EAA0B;AACxB,aAAOnC,SAAS,CAACmC,QAAD,CAAT,KAAwB,OAA/B;AACD;;;WAED,sBAAaA,QAAb,EAAuB;AACrB,aAAOnC,SAAS,CAACmC,QAAD,CAAT,KAAwB,IAAxB,IAAgCnC,SAAS,CAACmC,QAAD,CAAT,KAAwB,oBAA/D;AACD;;;WAED,eAAMZ,SAAN,EAAiBa,KAAjB,EAAwBC,KAAxB,EAA+B;AAC7B,UAAMC,MAAM,GAAG;AACbf,QAAAA,SAAS,EAATA,SADa;AAEbY,QAAAA,QAAQ,EAAEnC,SAAS,CAACoC,KAAD,CAFN;AAGbC,QAAAA,KAAK,EAAEvC,kBAAkB,CAACuC,KAAD;AAHZ,OAAf;AAMA,WAAKxB,QAAL,GAAgB,KAAKA,QAAL,CAAc0B,MAAd,CAAqBD,MAArB,CAAhB;AACA,aAAO,IAAP;AACD;;;WAED,yBAAgB;AACd,UAAIE,aAAJ;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5B,QAAL,CAAc6B,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,YAAMH,MAAM,GAAG,KAAKzB,QAAL,CAAc4B,CAAd,CAAf;;AAEA,YAAI,CAACvC,UAAU,CAACoC,MAAM,CAACH,QAAR,CAAf,EAAkC;AAChC;AACD;;AAGD,YAAI,CAACK,aAAL,EAAoB;AAClBA,UAAAA,aAAa,GAAGF,MAAhB;AACA;AACD;;AAGD,YAAIpC,UAAU,CAACoC,MAAM,CAACH,QAAR,CAAV,IAA+BK,aAAnC,EAAkD;AAChD,cAAIA,aAAa,CAACjB,SAAd,CAAwBoB,OAAxB,OAAsCL,MAAM,CAACf,SAAP,CAAiBoB,OAAjB,EAA1C,EAAsE;AACpE,kBAAM,IAAIC,KAAJ,2IACoIJ,aAAa,CAACjB,SAAd,CAAwBoB,OAAxB,EADpI,eAC+KL,MAAM,CAACf,SAAP,CAAiBoB,OAAjB,EAD/K,OAAN;AAGD;AACF;AACF;;AAED,UAAIE,gBAAJ;AACA,UAAIC,mBAAJ;AACA,UAAIC,KAAJ;;AAEA,WAAK,IAAIN,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG,KAAK5B,QAAL,CAAc6B,MAAlC,EAA0CD,EAAC,EAA3C,EAA+C;AAC7C,YAAMH,OAAM,GAAG,KAAKzB,QAAL,CAAc4B,EAAd,CAAf;;AAEA,YAAIH,OAAM,CAACH,QAAP,KAAoBnC,SAAS,CAAC,gBAAD,CAAjC,EAAqD;AACnD,cAAI6C,gBAAJ,EAAsB;AACpB,kBAAM,IAAID,KAAJ,CAAU,qEAAV,CAAN;AACD;;AACDC,UAAAA,gBAAgB,GAAG,IAAnB;AACD;;AAED,YAAIP,OAAM,CAACH,QAAP,KAAoBnC,SAAS,CAAC,oBAAD,CAAjC,EAAyD;AACvD,cAAI8C,mBAAJ,EAAyB;AACvB,kBAAM,IAAIF,KAAJ,CACJ,0EADI,CAAN;AAGD;;AAED,cAAIG,KAAJ,EAAW;AACT,kBAAM,IAAIH,KAAJ,CACJ,+EADI,CAAN;AAGD;;AAEDE,UAAAA,mBAAmB,GAAG,IAAtB;AACD;;AAED,YAAIR,OAAM,CAACH,QAAP,KAAoBnC,SAAS,CAACC,EAAlC,EAAsC;AACpC,cAAI8C,KAAJ,EAAW;AACT,kBAAM,IAAIH,KAAJ,CAAU,0DAAV,CAAN;AACD;;AAED,cAAIE,mBAAJ,EAAyB;AACvB,kBAAM,IAAIF,KAAJ,CACJ,+EADI,CAAN;AAGD;;AAEDG,UAAAA,KAAK,GAAG,IAAR;AACD;AACF;AACF;;;WAMD,0BAAiBC,YAAjB,EAA+B;AAC7B,aAAO,CAAC,CAACzC,UAAU,CAACyC,YAAY,CAACC,WAAb,EAAD,CAAnB;AACD;;;WAED,iBAAQ1B,SAAR,EAAmByB,YAAnB,EAAiC;AAC/B,UAAME,KAAK,GAAG;AACZ3B,QAAAA,SAAS,EAAEA,SAAS,CAACoB,OAAV,EADC;AAEZQ,QAAAA,SAAS,EAAEH,YAAY,GAAGzC,UAAU,CAACyC,YAAY,CAACC,WAAb,EAAD,CAAb,GAA4C1C,UAAU,CAACC;AAFlE,OAAd;AAKA,WAAKM,OAAL,GAAe,KAAKA,OAAL,CAAayB,MAAb,CAAoBW,KAApB,CAAf;AACA,aAAO,IAAP;AACD;;;WAED,2BAAkB;AAEhB,UAAI,KAAKpC,OAAL,CAAa4B,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAMU,MAAM,GAAG,KAAKtC,OAAL,CAAaO,GAAb,CAAiB,UAAAgC,CAAC;AAAA,iBAAIA,CAAC,CAAC9B,SAAN;AAAA,SAAlB,CAAf;;AACA,YAAM+B,GAAG,GAAG,IAAIC,GAAJ,CAAQH,MAAR,CAAZ;;AAEA,YAAIE,GAAG,CAACE,IAAJ,KAAaJ,MAAM,CAACV,MAAxB,EAAgC;AAC9B,gBAAM,IAAIE,KAAJ,CAAU,iEAAV,CAAN;AACD;AACF;;AAGD,UAAI,KAAK/B,QAAL,CAAc6B,MAAd,KAAyB,CAA7B,EAAgC;AAC9B;AACD;;AAGD,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5B,QAAL,CAAc6B,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,YAAMH,MAAM,GAAG,KAAKzB,QAAL,CAAc4B,CAAd,CAAf;;AACA,YAAMgB,eAAe,GAAGnB,MAAM,CAACf,SAAP,CAAiBoB,OAAjB,EAAxB;;AAEA,aAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,OAAL,CAAa4B,MAAjC,EAAyCgB,CAAC,EAA1C,EAA8C;AAC5C,cAAMR,KAAK,GAAG,KAAKpC,OAAL,CAAa4C,CAAb,CAAd;AACA,cAAMC,cAAc,GAAGT,KAAK,CAAC3B,SAA7B;;AACA,cAAIe,MAAM,CAACH,QAAP,KAAoBnC,SAAS,CAAC,IAAD,CAAjC,EAAyC;AAEvC,gBAAIyD,eAAe,KAAKE,cAAxB,EAAwC;AACtC,oBAAM,IAAIf,KAAJ,gDACyCe,cADzC,uEACyHF,eADzH,CAAN;AAGD;AACF;;AAED,cAAIA,eAAe,KAAK1D,WAAW,CAAC4C,OAAZ,EAApB,IAA6CgB,cAAc,KAAK5D,WAAW,CAAC4C,OAAZ,EAApE,EAA2F;AACzF,kBAAM,IAAIC,KAAJ,CACJ,iJADI,CAAN;AAGD;;AAED,cAAI1C,UAAU,CAACoC,MAAM,CAACH,QAAR,CAAd,EAAiC;AAE/B,gBAAIsB,eAAe,KAAK,KAAK3C,OAAL,CAAa,CAAb,EAAgBS,SAAxC,EAAmD;AACjD,oBAAM,IAAIqB,KAAJ,wDACiDe,cADjD,yEACmIF,eADnI,8CAAN;AAGD;AACF;AACF;AACF;AACF;;;;;;SA7QkB/C,uB","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\nimport { DOCUMENT_ID } from './FirestoreFieldPath';\n\nconst OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  in: 'IN',\n};\n\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n};\n\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING',\n};\n\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({ ...f, fieldPath: f.fieldPath._toArray() }));\n  }\n\n  get orders() {\n    return this._orders;\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isInOperator(operator) {\n    return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY';\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value),\n    };\n\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    let hasInequality;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      // Set the first inequality\n      if (!hasInequality) {\n        hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && hasInequality) {\n        if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(\n            `Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '${hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`,\n          );\n        }\n      }\n    }\n\n    let hasArrayContains;\n    let hasArrayContainsAny;\n    let hasIn;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use more than one 'array-contains-any' filter.\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\",\n          );\n        }\n\n        hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        hasIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath._toPath(),\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc,\n    };\n\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath);\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (this._filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath) {\n            throw new Error(\n              `Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`,\n            );\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\n            \"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\",\n          );\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath) {\n            throw new Error(\n              `Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}